\input texinfo @c -*-texinfo-*-
@c $Id: galib.texi,v 1.5 2005-07-11 08:37:32 ron_lima Exp $
@c %**start of header
@setfilename galib.info
@settitle    Generic Algorithms Library
@c %**end of header

@c ** Inserts the version information into the current document
@copying
@c ** Copyrght
Copyright @copyright{} 2004 - Ronaldo Faria Lima - All rights reserved

@end copying

@titlepage
@c ** Title page

@title GALib
@subtitle A Generic Algorithms Library
@author Ronaldo Faria Lima

@c ** Copyright page
@page
@insertcopying
@end titlepage

@c ** Table of contents
@contents

@c ** The top node
@ifnottex
@node Top
@top GALib
@end ifnottex

@c ** Main Menu
@menu
* Introduction       :: An introduction to the GA Lib
* Principles         :: Principles of the library
* Common             :: Common declarations in the library
* List :(list).      :: Single-linked lists
* DList:(dlist).     :: Double-linked lists
* CList:(clist).     :: Circular lists
* IVector:(ivector). :: Infinite vectors
* Stack:(stack).     :: Stacks 
* Queue:(queue).     :: Queues
* Licenses :: Licenses and other information
@end menu

@node Introduction, Principles, Top, Top
@chapter Introduction to G.A. Lib

The idea of writing a library with generic algorithms is not new. In
fact, several projects in Sourceforge are libraries that intend to
implement all general public domain algorithms like lists, queues and
so on. Also, there is a GNU implementation of such algorithms
(Glib). In fact, G.A. Lib is a project that was born from my studies
in algorithms. As a programmer, I was always looking for such a
library. However I wanted to know the algorithms, not only play with
someone else's library. Then I decided to write a small library with
all the ideas that I got from my studies.

This library intends to be as general as possible. As a programmer, I
was always developing some sort of algorithm that is implemented in
this library. Actually, I was always reimplementing those
algorithms. I believe that all C programmers around the world do
exactly the same.

This library intends to be as portable as possible. This library has
born in unix but my primary idea is to make it work in every operating
system that supports the Standard C library. The library is
self-contained and do not need any other library in order to be
compiled or used.

@node Principles, Common, Introduction, Top
@chapter Principles used in G.A. Library

For every algorithm there is a descriptor that encapsulates all the
needed data to implement it. Even if you read and understand the
header files where the descriptors are defined, do not use the inner
fields of it. Treat them as ``opaque'' data. The descriptors internals
may change from one release to another and it is not guaranteed that
the field that you are using will be available in the next release of
the library with the same name. It can be even deleted.

The descriptors are containers that will hold up all data to implement
not only the algorithms but, also, to hold the data you are adding to
the algorithm.

Each function that implements a given algorithm is an operation
applied uppon the descriptor. This is an object-oriented approach, for
sure. However the implementation, even being thought in an
object-oriented manner, has been made straightforward C. The main
principle of the library is to follow the KISS principle: Keep It
Simple and Small.

The error reporting in G.A. Library follows the POSIX standards. Every
function returns 0 when successfull or the error code if something
went wrong. The error number describes exactly what failed during the
operation.

@subsection Internal headers

G.A. library makes use of the central internal header gacommon.h. This
header is automatically included by the others since it has several
declarations that are common throughout the library. You are advised
to not include this header file directly. Since it is an internal
header file it can change without notice. If you include it directly,
you are doing it by your own risk.

@node Common, Licenses, Principles, Top
@section Common declarations

Some declarations are common for all algorithms within the
library. All those declarations are done inside internal header files
as discussed in previous section.

@subsection Constants

Some constants are declared as macros and other as enumerations. Here
are the full set of common constants used through the library.

@itemize @bullet
@item position_t

The position_t enumeration describes a position where you may operate
within the algorithms of the G.A. Library. Depending on the operation,
some of these constants may not be supported.

@itemize @bullet
@item POS_NONE
Dummy operation. Depending on the algorithm, this constant informs to
the operation to not update the current pointer.
@item POS_HEAD
Operates on the head. Depending on the algorithm, the ``head'' is the
beginning of the data list in memory.
@item POS_TAIL
Operates on the tail. Depending on the algorithm, the ``tail'' is the
end of the data list in memory.
@item POS_NEXT
Operates on the next item. 
@item POS_CURR
Operates on the current selected item.
@item POS_PREV
Operates in the previous item.
@end itemize

@item Error constants
Several error constants were introduced in order to inform error
situations that may happen inside the G.A. Library operations. These
error constants follow the same naming conventions adopted by the
errno.h header file. G.A. Library is not using the constants already
declared in errno.h header file because several of them may not be
available on different systems. So, G.A. Library declares the
following constants in order to avoid some sort of system dependency.
@itemize @bullet
@item EGAINVAL
Invalid argument. Some of the arguments provided for the operation is
not valid for the operation context.
@item EGANOMEM
No more memory. The operation tried to allocate more memory to hold
the caller's request but the operating system said no.
@item EGABADC
Bad current pointer. The operation needed a valid current
position. However the current position was not valid at all.
@end itemize
@end itemize

@subsection Macros

Some common macros provides access to the internal parts of the
descriptors used in the algorithms.

@itemize @bullet
@item descriptor_size(descriptor)
Returns the current size of the descriptor provided. The size is given
in items stored inside the descriptor, not in bytes.
@end itemize

@subsection Data types

The other data types are used within the library.
@itemize @bullet
@item deallocator_t
Pointer to a void function that receives a void pointer as
argument. This is used to inform the library what is the deallocator
you want to use to clean each single object inserted into the library
containers.

Prototype: void (deallocator_t) (void *);
@item compare_t
Comparison function that is called by some algorithms that sorts the
elements.  

Prototype: int (compare_t) (const void *, const void *);
@end itemize

@c ** Includes the licenses 
@node Licenses, , Common, Top
@include licenses.texi

@bye
