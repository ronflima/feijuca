\input texinfo @c -*-texinfo-*-
@c $Id: dlist.texi,v 1.2 2004-03-28 22:51:39 ron_lima Exp $
@c %**start of header
@setfilename dlist.info
@settitle    Double linked lists
@c %**end of header

@copying
@c ** Copyrght
Copyright @copyright{} 2004 - Ronaldo Faria Lima - All rights reserved

Last update: @value{UPDATED}

Revision: @value{VERSION}
@end copying

@titlepage
@c ** Title page

@title G.A. Library
@subtitle Double linked lists interface
@author Ronaldo Faria Lima

@c ** Copyright page
@page
@insertcopying
@end titlepage

@c ** Table of contents
@contents

@c ** The top node
@ifnottex
@node Top
@top DList
@end ifnottex

@c ** Main Menu
@menu
* algorithm :: Algorithm implemented by G.A. Library
* constants :: Constants used in library
* macros    :: Macros defined by dlists.h
* data types:: Data types
* functions :: Description of all available functions
* Licenses  :: Licenses and other information
@end menu

@node algorithm, constants, Top, Top
@chapter Double linked lists in G.A. Library
G.A. Library implements double linked lists through the header file
<dlist.h>. The list descriptor contains always the first and the last
elements for fast access in the list. Navigation in the list is
possible only in both ways.

Double linked lists are useful when you have a collection of data that
must be traversed in two directions in memory and you won't know the
amount of data that will be stored in memory.

The implementation for double linked lists was done from scratch,
instead of using some of the single-linked lists routines or data
types. It would be possible to reuse the LIST descriptor by adding
into it a new field. However, this unused field would spend useless
memory if you want to use the single-linked lists stuff.

Until this release, no thread safety was analyzed or even implemented
in the algorithms. So, thread safety is not guaranteed.

@node constants, macros, algorithm, Top
@chapter Constants

The only defined constants defines how to iterate in the list.

@itemize @bullet
@item HEAD:
Operations over the beginning of the list.
@item TAIL:
Operations over the tail of the list.
@item NEXT:
Operations within the next item of the list, based on the current
pointer.
@item PREV:
Operatarions within the previous item of the list based on the current
pointer.
@item CURR:
Used to operate over the current item of the list
@end itemize

@node macros, data types, constants, Top
@chapter Macros
@itemize @bullet
@item list_size (list):
Receives a list descriptor as argument and returns the list size in
number of elements. This is reused from the list.h header file and is
common for both implementations.
@end itemize

@node data types, functions, macros, Top
@chapter Data types
The following data types are defined for list implementation.
@itemize @bullet
@item void (* deallocator_t)(void *data):
Pointer to a user function that will be called in order to deallocate
memory for each data element of the list. This datatype is being
reused from list.h.
@item DLIST_ELEMENT:
Data structure that describes a list element. There is no need to use
this data type since this is used internally by the list descriptor.
@item DLIST:
Data structure that decribes the list descriptor. This is used to hold
all needed data to implement the list. There is no need to access
directly any element of this structure since they are manipulated by
the functions of the library.
@end itemize

@node functions, Licenses, data types, Top
@chapter Functions
@menu
* dlist_alloc :: List allocator function
* dlist_free  :: List deallocator function
* dlist_get   :: Element getter
* dlist_insert:: Inserts a new element
* dlist_move  :: Iterates the list
* dlist_del   :: Deletes a single element of the list
@end menu
@node dlist_alloc, dlist_free, functions, functions
@section int dlist_alloc (LIST ** list, deallocator_t dealloc)
Purpose: Allocates a new list and initializes the list descriptor

Parameters:
@itemize @bullet
@item list:
List descriptor pointer passed by reference (required)
@item dealloc:
Deallocator pointer function for the user-defined deallocation
function (required)
@end itemize

Return values:
@itemize @bullet
@item 0: success
@item -1: failure
@end itemize

Error values in errno:
@itemize @bullet
@item ENOMEM: 
The function could not allocate memory for the list descriptor
@item EINVAL:
The function have received an invalid deallocator function pointer
@end itemize

@emph{Hints}:
@itemize
@item
The deallocator function is a user-defined function that will handle
the deallocation of the data stored in the list. Since this set of
functions were designed to work over any kind of user-defined data, so
the deallocation will be responsibility of the user, since the library
has no way to know how to handle deallocations of generic data. This
function must have the following prototype:
@example
void deallocator (void *data);
@end example
You will note that this prototype is exactly the same definition of
the @samp{deallocator_t} data type.
@end itemize
@node dlist_free, dlist_get, dlist_alloc, functions
@section int dlist_free (LIST ** list)
Purpose: Deallocates each element and releases the entire list from
memory

Parameters:
@itemize @bullet
@item list:
The list descriptor
@end itemize

Return values:
@itemize @bullet
@item Always returns 0
@end itemize

Error values in errno: 
@itemize @bullet
@item EINVAL: 
The deallocator was not set. If set, it means that the library has
some sort of bug or your application memory is corrupted somehow. At
this point, the deallocator function should be set.
@end itemize

@node dlist_get, dlist_insert, dlist_free, functions
@section int dlist_get (LIST * list, void **data, int whence)
Purpose: Gets an element data from the list and make it possible to
navigate the list after getting the data. 

Parameters:
@itemize @bullet
@item list:
The list descriptor
@item data:
Data to be get. Remain untouched if the function could not retrieve
data for some reason.
@item whence:
This parameter indicates how to navigate the list after the data is
retrieved.
@itemize @bullet
@item CURR: 
Gets the current element data and do not update the current pointer.
@item NEXT:
Gets the current element data and makes the current pointer point to the
next element (moves the list)
@item PREV:
Gets the current element data and makes the current pointer point to
the previous element (moves the list).
@end itemize
@end itemize

Return values:
@itemize @bullet
@item 0: success
@item -1: failure
@item EOF: if the end of the list was reached
@end itemize

Error values in errno:
@itemize @bullet
@item EINVAL: 
if the whence parameter has invalid options
@end itemize
@emph{Hints}: 
@itemize
@item
To get the first element, use dlist_move function (see
@xref{dlist_move}) and then use this function with whence=CURR.
@item
This function was designed, basically, to retrieve data from the list
by iterating it from the current position. The data is
retrieved and not deleted from the list.
@item 
This function will return, always, the data from the current position
of the list. The @samp{whence} parameter says how the list will be
navigated after the current element is returned.
@item
For error checking it is a good idea to check, always, the errno
global data structure since EOF is a macro that expands to -1. The
design of this function complies with several Standard C function
libraries.
@end itemize
@node dlist_insert, dlist_move, dlist_get, functions
@section int dlist_insert (LIST * list, const void *data, int whence)
Purpose: Inserts a new element in the list

Parameters:
@itemize @bullet
@item list:
List descriptor
@item data:
Data pointer to be inserted in the list
@item whence:
Where to insert the new parameter:
@itemize @bullet
@item NEXT: 
As the next element based on the current position.
@item PREV:
As the previous element, based on the current position.
@item HEAD:
As the list head.
@item TAIL:
As the list tail.
@end itemize
@end itemize

Return values:
@itemize @bullet
@item 0: success
@item -1: failure
@end itemize

Error values in errno:
@itemize @bullet
@item ENOMEM:
It was not possible to allocate memory for the element descriptor for
the list.
@item EINVAL:
The @samp{whence} parameter is not valid.
@item EFAULT:
The operation in @samp{whence} was selected to be done using the
current pointer but the current pointer is not set.
@end itemize

@emph{Hints}:
@itemize
@item 
This function updates the value of the current pointer. So, if the
list was initialized and then several elements were inserted, the
current pointer will always point to the last inserted element.
@end itemize

@node dlist_move, dlist_del, dlist_insert, functions
@section int dlist_move (LIST * list, int whence)
Purpose: Moves the current pointer to a specific location within the
list

Parameters:
@itemize @bullet
@item list:
The list descriptor
@item whence:
How to move the pointer:
@itemize @bullet
@item HEAD:
Moves the pointer to the beginning of the list
@item TAIL:
Moves the pointer to the end of the list
@item NEXT:
Moves the pointer to the next item of the list
@end itemize
@end itemize

Return values:
@itemize @bullet
@item 0: success
@item -1: failure
@item EOF: End of list reached
@end itemize

Error values in errno:
@itemize @bullet
@item EINVAL:
The whence parameter has values not recognized by the function.
@end itemize

@emph{Hints}:
@itemize
@item
If the list was never moved, the current pointer points to
nowhere. Any try to move the pointer to anywhere that is not the
beginning or the end of the list will return EOF.
@item
For error checking it is a good idea to check, always, the errno
global data structure since EOF is a macro that expands to -1. The
design of this function complies with several Standard C function
libraries.
@end itemize
@node dlist_del, , dlist_move, functions
@section int dlist_del (LIST * list, void **data, int whence)
Purpose: Deletes a single element from the list

Parameters:
@itemize @bullet
@item list:
The list descriptor
@item data:
Data storage arena to store the data extracted from the list
@item whence:
Where to delete the item:
@itemize @bullet
@item CURR:
Deletes the current item
@item NEXT:
Deletes the next item based on the current pointer
@item PREV:
Deletes the previous item based on the current pointer
@end itemize
@end itemize

Return values:
@itemize @bullet
@item 0: success
@item -1: failure
@item EOF: 
if the list is empty or if the current pointer is not set.
@end itemize

Error values in errno:
@itemize @bullet
@item EINVAL:
Returned when the deallocator and the data storage are not provided.
@end itemize

@emph{Hints}:
@itemize
@item
If the list was never iterated, the current position points to
nowhere. No deletion will take place for operations using whence=CURR,
NEXT or PREV.
@item
Always check errno for error checking, since EOF expands to -1.
@item 
If you provide NULL for the data storage, the function will call the
deallocator provided to free the data memory.
@item
If you delete the current element (whence=CURR), the current pointer
will be reset to NULL and if you issue again the same operation, it
will fail by returning to the caller EOF, since the current pointer
was reset due to the previous operation.
@end itemize

@c ** Includes the licenses 
@node Licenses, , functions, Top
@include licenses.texi

@bye
